# Туториал по GIT

## __```git-init```__

Инициализирует `git` в текущей директории и создает директорию `.git` с настройками и ндексами `git`'a.
```bash
git init
```
___
## __```git add --all```__

Добавляем все измененные файлы в `git`.

Игнорирует содержимое файла `.gitignore`
```bash
git add --all
```

Добавляем файл к индексу.
```bash
git add <имя_файла>
```
___

## __```git diff```__

Показывает разницу между файлами
```bash 
git diff [с чем сравнить]
```
Сравнить можно, например с каким-ть коммитом, унав его id из `git log`.

\+ стоят у того что добавляется

\- стоят у того что убирается в текущей версии по сравнению с камитом
___

## __```git log```__
Позволяет вывести список всех комитов.
```bash
git log
```

Cписок камитов и отношения между вевями в виде графа:
```bash
git log --graph
``` 
___
# Работа с ветками


### __`git branch`__
Показывает список веток
___
### __`git branch имя_ветки`__
Создает новую ветку. Также можно сипользовать:
```bash
git checkout -b имя_ветки
```
Чтобы сразу создать новую ветвь и перейт в неё.
___
### __`git branch -d имя_ветви`__
Удаляем ветку. Удаление происходит если ветка уже слита.
___
### __`git branch -D имя_ветви`__
Насильное удаление ветви без проверки того, что она уже слита.
___
# Перемещение по веткам

`HEAD`- это символическое имя текущего выбранного коммита.

По-умаолчанию HEAD указывает на последний коммит из локального дерева. 

Обычно `HEAD` указывает на имя ветки, например `master` или `bugFix`. При коммите мы меняем статус ветки и это вижно через изменение `HEAD`.

### __Detaching HEAD__
Отделение `Detaching HEAD` означает присвоение `HEAD` не ветке, а конкретному коммиту.

### __`git checkout`__

Позволяет переключиться на нужный коммит указав его `hash`.
```bash
git checkout commit_hash
```

Или можно переключиться на ветвь разработки:
```bash
git checkout branch_name
```

При переходе на коммит, текущий указатель `*HEAD` будет отделен от листа ветки. Чтобы его вернуть можно ввести команду перехода на ветку:
```bash
git checkout master
```

Можно использовать не только __абсолютные__ ссылки в виде коммитов или названий веток, а переходить к их родительским элементам, с помощью __относительных__ ссылок: `^` или `~<num>`.

Чтобы перейти в родительский элемент от ветки `master` (на один коммит назад по дереву):
```bash
git checkout master^
```
Чтобы перейти на 2 элемента назад:
```bash
git checkout master^^
```
Или то же самое можно записать в виде относительной ссылки:
```bash
git checkout master~2
```
Вместо названий веток можно использовать идентификаторы коммитов.

При переходе по __относительным ссылкам__ можно использовать указатель `HEAD`, например, чтобы перейти на 2 уровеня назад:
```bash
git checkout HEAD^^
```
или 
```bash
git checkout HEAD~2
```
___
### __`git reflog`__
Появилась в последних версиях `git`
Показывает всю историю и ветки, что происходила и когда ветка была главной.
Сочетая `git reflog` и `git diff ID` можно просмотреть разницу между камитами.
___

# Слияние веток

### __`git merge branch_name`__
```bash
git merge branch_name
```
Вливание в текущую ветку указанной ветви `branch_name`.
___
### __`git rebase branch_name_<куда_переносим>`__
При ребейзе git по сути копирует набор коммитов и переносит их в указанное место. 

Преимущество `rebase` в том, что с его помощью можно делать чистые линейные последовательности коммитов.
Например, если существеут ветка `master` и `bugFix`, и мы хотим сдвинуть наши изменения из ветки `bugFix` прямо на вершину ветки `master`, то находясь в ветку `bugFix` можем набрать следующую команду:
```bash
git rebase master
```
Таким образом мы скопируем и перенесем коммиты из ветки `bugFix` в ветку `master`, как будто изменения делались последовательно, хотя на самом деле параллельно. В ветке `master` сощдастся новый коммит.

Если делаем `rebase master` при этом находясь в `master^` или в другом потомке, то указатель просто сдвинется на ветку `master`.
___

# Работа с удаленным репозиторием


### __`git remote add origin url`__
Чтобы связать локальный репозиторий с удаленным репозиторием используется команда `git remote add`, например:
```bash
git remote add origin git@github.com:username/project.git
```
`origin` - это название, которое мы даем этому удаленному репозиторию.

Затем переименовваем текущую ветку `master` в `main`, т.к. на гитхабе при создании репо главная ветка это `main`:
```
git branch -M main
```
Затем отправляем командой `git push` данные из ветки main в удаленный репозиторий `origin`:
```bash
git push -u origin main
```
Далее можноотправлять изменения просто командой
```bash
git push
```
___
### __`git pull`__
Данная команда загружает актуальную версию с удаленного репозитория в локальный. 
```bash
git pull
```
`pull` - это составная команда, она не только загрузит состояние с гитхаба, но и произведет `merge` с текущим состоянием локального репозитория.

___
## pull request
Чтобы отправить запрос на изменение в чужой репозиторий
нужно:
1. Создать форк `fork` чужого проекта на своем аккаунте.
2. Внести изменения
    1. Склонировать форк к себе в локальную среду командой 
    ```bash
    git clone https://github.com/my_nickname/forked_project
    ```
    2. Создать ветку с изменениями, напрмиер:
    ```bash
    git branch fixes
    ``` или
    ```bash
    git checkout -b fixes
    ```
    3. Внести все изменения в эту ветку:
    ```bash
    git add file
    git commit -m "fix: fix description"
    ```
    4. Запушить изменения в свой аккаунт:
    ```bash
    git push
    ```
3. Подтвердить создание `pull request`'a на [github](https://github.com) с изменениями.

Если вы не делаете форк, и пытаетесь загруить в оригинальный репозиторий, то система это не позволит.
Надо сделать копию клон и потом отправить клон-копию себе. Создастся запрос на изменение в главную ветку в оригинал.

___
## quiz

git clone - клонирование, создание локальной копии удаленного репозитория.

fork - копия чужого реозитория

git pull - стянуть все изменения из удаленного репозитория
 - создает вопрос слияния веток, иногда проще клонировать весь блок в отдельную папку

`git pull` - выкачивает данные из репозитория и делает слияние с локальным репозиторием
Если не нужно слияние то луче git clone

`git push` - отправляет изменения в удаленный репозиторий

`git push ssh_name` или `git push https://...`

git должен быть авторизован на внесение изменений в удаленный репозиторий, чтобы выполнить команду git push

`git add` - добавляет файлу версионность в локальном репозитории

`git checkout` - позволяет перемещаться между ветками и сохранениями

`git diff` - разница между текущей и зафиксированной версией файла

`git commit` - фиксация изменений в репозитории

`git branch` - вывод всех веток на экран

`git branch new_branch_name` - создание новой ветки


`git merge branch_name` - слияние веток: в текущую branch_name

`git merge lists` - в текущую ветку добавит информацию из lists

* git init
* git status
* git add
* git commit -m "comment"
* git log
* git reflog
* got clone url - не сливаем старый проект 
* git pull - вся история и ветки сливаются
* git push - отправить в удаленный репозиторий
